{"name":"Babel RPC","tagline":"An RPC framework using JSON over HTTP","body":"![Babel](media/logo.png)\r\n\r\nBabel is an IDL parser and RPC framework using JSON over HTTP. IDL files describe models and web services. The babel tool allows you to generate client and server code in multiple languages from the IDL file.\r\n\r\n## Supported Languages\r\n\r\n* [C#](csharp.md)\r\n* [Java](java.md)\r\n* [Test Harness](testharness)\r\n* [ASP](asp.md) (client only)\r\n\r\n### Future support\r\n\r\n* Objective-C/iOS (client only)\r\n* Python\r\n* Ruby\r\n* Go\r\n* JavaScript\r\n* PHP\r\n\r\nBabel Syntax\r\n============\r\n\r\nBabel's syntax should be familar to most programmers using C-like or JavaScript-like languages.\r\n\r\nThe Babel IDL File\r\n------------------\r\n\r\nA Babel file consists of a header and defintions. The header includes `import` and `namespace` statements. The rest of the file consists of `const`, `enum`, `struct`, and `service` declarations.\r\n\r\nIn general, the format is C-like. In most objects, a comma or semicolon is accepted as a separator, but isn't required.\r\n\r\nIn general, the parse tree of the IDL maintains the order of the items in the original IDL file.\r\n\r\n### Comments\r\n\r\nOrdinary comments are ignored by the parser.\r\n\r\n\t// This is a comment\r\n\t/* so is this */\r\n\r\n### Documenation Comments\r\n\r\nDocumentation comments may appear *before* a `const`, `enum`, `struct`, or `service` definition. They may also be used before field and method definitions, and at the top of the babel file.\r\n\r\n\t/// This is a documentation comment\r\n\t/** So is this */\r\n\r\nDocumentation comments are written to the output files in a format appropriate for the language. File-level documentation comments (at the top of the babel file) are written to each generated output file. This is a good place to put overview or copyright information.\r\n\r\nMake sure documentation comments are *awesome* for best results! They are placed into the generated code and any UIs we build for documentation purposes.\r\n\r\n### Data Types\r\n\r\nBabel supports various primitive data types. *Try to avoid types with a language-specific behavior unless you really know what you are doing.*\r\n\r\n<table><thead><tr><th>IDL type</th><th>Examples (JSON)</th><th>Description</th><th>Range</th></tr></thead>\r\n<tbody>\r\n<tr><td>bool</td><td>false, true</td><td>Boolean</td><td>false, true</td></tr>\r\n<tr><td>byte</td><td>0, 1, ...</td><td>Unsigned 8-bit integer</td><td><b>Warning: Language-specific behavior!</b><br/>\r\n0 to 255<br/>\r\nJava: 0 to 127</td></tr>\r\n<tr><td>int8</td><td>-1, 0, 1, ...</td><td>Signed 8-bit integer</td><td>-128 to 127</td></tr>\r\n<tr><td>int16</td><td>-1, 0, 1, ...</td><td>Signed 16-bit integer</td><td>-32,768 to 32,767</td></tr>\r\n<tr><td>int32</td><td>-1, 0, 1, ...</td><td>Signed 32-bit integer</td><td>-2,147,483,648 to 2,147,483,647</td></tr>\r\n<tr><td>int64</td><td>\"-1\", \"0\", \"1\", ...</td><td>Signed 64-bit integer</td><td>-9,223,372,036,854,775,808 to 9,223,372,036,854,775,807</td></tr>\r\n<tr><td>float32</td><td>3.14</td><td>Floating point with 32-bit precision</td><td>-3.402823e38 to 3.402823e38</td></tr>\r\n<tr><td>float64</td><td>3.14159</td><td>Floating point with 64-bit precision</td><td>-1.79769313486232e308 to 1.79769313486232e308</td></tr>\r\n<tr><td>string</td><td>\"\\thello, world\"</td><td>String, assumed to be UTF-8 or Unicode capable</td><td>0 to any number of characters</td></tr>\r\n<tr><td>datetime</td><td>\"2013-09-09T13:44:22.341-05:00\"<br/>\"2013-09-09T18:44:22.341Z\"</td><td>Date-time type. (Date constants are not supported.)</td><td>Specific range outside of 1980s and up varies by language</td></tr>\r\n<tr><td>decimal</td><td>\"3.2415\"</td><td>128-bit decimal data type (Decimal constants are not supported.)</td><td>\r\n<b>Warning: Language-specific behavior!</b><br/>\r\nASP: -922,337,203,685,477.5808 to 922,337,203,685,477.5807</br/>\r\n.Net: &#x00B1;1.0&times;10e-28 to &#x00B1;7.9&times;10e28<br/>\r\nJava: <br/>\r\nOther: Represented as a string</td></tr>\r\n<tr><td>char</td><td>\"\\r\", \"A\"</td><td>Single character, assumed to be UTF-8 or Unicode capable</td><td>Single character</td></tr>\r\n<tr><td>binary</td><td>\"YXNhZGFzZAo=\"</td><td>Binary data stored in byte arrays (based64 encoded string)</td><td>0 bytes to any number of bytes</td></tr>\r\n</tbody></table>\r\n\r\nPrimitive are generally nullable (i.e. optional). Initializers may be used to ensure that a field has a default value.\r\n\r\nFinaly, the `binary` type is used to represent binary data stored in byte arrays. It serializes more efficiently than a list of bytes.\r\n\r\n(Also see [Language-Specific Issues](langissues.md) and [About JSON](JSON.md).)\r\n\r\n#### Containers\r\n\r\nMaps and lists may be defined.\r\n\r\nAn list can contain primitive types or complex types defined by a `struct`. Lists may contain null values.\r\n\r\nA map's key can only contain primitive types, but the value can contain any type. Null keys are not supported. Values set to null are not guaranteed to be preserved across the wire.\r\n\r\n<table><thead><tr><th>IDL type</th><th>Examples</th><th>Description</th></tr></thead>\r\n<tbody>\r\n<tr><td>list</td><td>list&lt;int32&gt;<br/>list&lt;Foo&gt;<br>list&lt;list&lt;string&gt;&gt;</td><td>A list of values</td></tr>\r\n<tr><td>map</td><td>map&lt;int32,string&gt;<br/>map&lt;string,Foo&gt;<br/>map&lt;string,list&lt;int32&gt;&gt;</td><td>A map or dictionary</td></tr>\r\n</tbody></table>\r\n\r\n#### Initializers (Defaults)\r\n\r\nIn the data model generated for any given language, maps and lists are automatically initialized to an empty, non-null container. Manually nulling out a container will cause Babel's Protocol (serialization) layer to generate an exception.\r\n\r\nInitializing primitive types has the simple effect of a constructor initializing the value. Because Babel's types are all nullable, this helps ensure that callers do the right thing. However, the server code should still check for null in its validation step.\r\n\r\nThat being said, when a field is nulled out but has a default value, the server will still see the default value. This is because the JSON (and other protocols) tend to minimize the data sent via the transport. If a field is null, it is not sent over the wire.\r\n\r\nWhen the server parses the JSON, the model is initialized. Since the JSON doesn't contain a definition for the null field, it is never assigned and the default value is used. Think of initializers as a way to set a default value.\r\n\r\n<b>NOTE - the following IDL primitive types do not support initializer values: datetime, decimal, and binary.</b>\r\n### Attributes\r\n\r\nAttributes can be placed on `struct`, `field`, `service`, and `method` definitions.\r\n\r\n\t[MessageId(\"OperatedBy\", MessageCategory = \"ItineraryView\"),\r\n\t ValidateStringLength(MaxLength = 32), ValidateRequired]\r\n\r\nMultiple attribute blocks can be used over a single item:\r\n\r\n\t[Foo]\r\n\t[Bar]\r\n\r\n#### Scopes\r\n\r\nAttributes may be used with a scope. When a scope is defined, the attributes can be passed-through by the code generator if the scope is enabled on the babel command line.\r\n\r\n\t@myScope [MyAttribute]\r\n\r\nAttributes without scopes are reserved for use by babel.\r\n\r\n**Note:** babel does not automatically add import statements for pass-through attributes. Thus, you will usually need to specify their full namespace:\r\n\r\n\t@scope [Company.Validator.ValidateRequired]\r\n\r\n### import\r\n\r\nUse the import statement to load another IDL file into this one. Imports must occur at the top of the IDL file and are relative to the current file. Use a forward slash as a directory separation (this way it works across platforms).\r\n\r\n\timport \"tower/includeMe.babel\"\r\n\r\nSymbols must be unique across all files. While output namespaces are supported, it is assumed that all of the symbols will be unique across those namespaces.\r\n\r\n### Default namespace\r\n\r\nA default namespace is used to avoid specifying it for all languages. _The default namespace is required_ and is written like a URL. Examples:\r\n\r\n\tnamespace company.com/Tower/Babel\r\n\tnamespace company.co.uk/Tower/Babel\r\n\r\nThis maps to different languages as shown in the following example.\r\n\r\n<table><thead><tr><th>Language</th><th>Result</th></tr></thead><tbody>\r\n<tr><td>java</td><td>com.company.tower.babel</td></tr>\r\n<tr><td>csharp</td><td>Company.Tower.Babel</td></tr>\r\n<tr><td>asp</td><td>TowerBabel</td></tr>\r\n<tr><td>python</td><td>TowerBabel</td></tr>\r\n<tr><td>ruby</td><td>TowerBabel</td></tr>\r\n<tr><td>ios</td><td>BAB</td></tr>\r\n<tr><td>php</td><td>TowerBabel</td></tr>\r\n<tr><td>javascript</td><td>TowerBabel</td></tr>\r\n<tr><td>go</td><td>company/tower/babel</td></tr>\r\n</tbody></table>\r\n\r\n### Language-specific namespace\r\n\r\nThe `namespace` statement is used to define the namespace for a given language (see supported languages above).\r\n\r\n\tnamespace csharp \"Company.Tower\"\r\n\r\nBabel doesn't validate these. In fact, babel assumes that all of the symbols that are defined are unique across all included files.\r\n\r\n### enum\r\n\r\nEnumerated types may be defined with their associated values.\r\n\r\n\t/// Enumeration of supported languages\r\n\tenum Languages {\r\n\t\tENGLISH = 1,\r\n\t\tGERMAN = 2\r\n\t}\r\n\r\nEnumerated types must specify their integer values and cannot reference other enums or constants.\r\n\r\nEnumerations can be used as initializers for enum fields and parameters.\r\n\r\n### const\r\n\r\nConstants can be defined for chars, integers, doubles, booleans, and strings. Constants must be unique within their declaration block.\r\n\r\n\t/// Miscellaneous Constants\r\n\tconst Misc {\r\n\t\tCOUNT = 50;\r\n\t\tPI = 3.14159;\r\n\t\tEmail = \"someone@company.com\";\r\n\t\tEmailValid = false;\r\n\t}\r\n\r\nConstants can be used to initialize fields and parameters, provided that the data type matches.\r\n`All decimal constant values become datatype of double, so you can only use these constants to initialize fields of type double.`\r\n\r\n### struct\r\n\r\nA structure defines the fields that will be transmitted in web services calls. Fields may have primitive data types or be other structures.\r\n\r\nStructures and fields within them both support docmentation comments and attributes.\r\n\r\n\t/// Documentation comment for Bar\r\n\t[MessageCategory(\"Travel\")]\r\n\tstruct Bar {\r\n\t\tdatetime C\r\n\t\t/// D is for David\r\n\t\t/// Or so you would think\r\n\t\t[SomeAttribute()]\r\n\t\tlist<Bar> D;\r\n\t\t[ValidateRequired, ValidateRegularExpression(Pattern = \"[A-Za-z0-9]{2,2}\")]\r\n\t\tstring XXX = \"foo\"\r\n\t\t/** YYY is funny */\r\n\t\t[ValidateStringLength(MaxLength = 32),\r\n\t\tValidateRequired]\r\n\t\tstring YYY\r\n\t\t[Lang(ID=\"ok\")]\r\n\t\tInfo E\r\n\t\tFoo State = Foo.OFF\r\n\t\tFoo2 Name\r\n\t\tlist<string> F\r\n\t\tmap<int32,string> X\r\n\t\tmap<int32,Info> Y\r\n\t\tmap<string,list<Info>> Z\r\n\t\tint32 SomeInt\r\n\t}\r\n\r\nStructures may be defined as `abstract`. See below for more information.\r\n\r\n#### Composing Data Structures\r\n\r\nStructures can be composed by extending other structures, so that they have all of the base fields. This is done with the `extends` keyword.\r\n\r\n\tabstract struct Bar {\r\n\t\t// fields\r\n\t}\r\n\r\n\tstruct Foo extends Bar {\r\n\t\t// fields\r\n\t}\r\n\r\nObject composition is different from a traditional object-oriented language in several ways. Babel is designed to create *data transfer objects* for passing data around web services. It's not an object-oriented format per se - instead it is focused on easily composing your data. That being said, it does generate a class hierarchy in most languages that support it.\r\n\r\nKey differences you will note:\r\n\r\n* Unlike OO languages, polymorphism is **not** supported. Thus, `list<Bar>` will never have a `Foo` object in it. This is a very important distinction.\r\n* Overriding fields is *not* supported. All fields across the entire inheritance chain must be uniquely named.\r\n* The is no concept of *virtual* members or anything similar.\r\n* No multiple inheritance.\r\n* The `abstract` keyword prevents any field from using the struct as its type. Additionally, code generators may use the keyword to generate abstract classes.\r\n\r\n##### Why no polymorphism?\r\n\r\nPolymorphism might be supported in the future, but we felt that it adds unnessessary complexity and might even lead to bad DTO designs.\r\n\r\n* JSON serializers are far more complex (and slower) when supporting polymorphism.\r\n* Polymorphism is not supported by all target languages.\r\n* Major, industry-proven tools like Thrift and Protocol buffers don't support it.\r\n\r\nWe want to see how use of Babel evolves. While we recognize some very well-known cases like segments, the vast majority of use cases may not need it.\r\n\r\n##### Design Alternatives\r\n\r\nSince this polymorphic case *won't* work:\r\n\r\n\tstruct Trip {\r\n\t\tlist<Segment> Segments;\r\n\t}\r\n\r\nA common alternative is:\r\n\r\n\tstruct Trip {\r\n\t\tlist<AirSegment> AirSegments;\r\n\t\tlist<HotelSegment> HotelSegments;\r\n\t\tlist<CarSegment> CarSegments;\r\n\t\t// etc.\r\n\t}\r\n\r\nThis alternative is, interestingly enough, how the TripIt API works. It's a good model when you don't know who is using your service and what tools they are using.\r\n\r\nPlease keep in mind that the client libraries generated by Babel can be used with polymorphism or \"duck typing\" in your code - just not in the DTO objects themselves. For instance, you could create a list of `Segment` objects and sort them in your code. They just can't go over the wire that way.\r\n\r\nOther alternatives involve using a single `Segment` type:\r\n\r\n\tstruct AirProperties {}\r\n\tstruct HotelProperties {}\r\n\tstruct CarProperties {}\r\n\r\n\tstruct Segment {\r\n\t\t// Common Properties\r\n\t\tAirProperties Air;\r\n\t\tHotelProperties Hotel;\r\n\t\tCarProperties Car;\r\n\t}\r\n\r\n\tstruct Trip {\r\n\t\tlist<Segment> Segments;\r\n\t}\r\n\r\n### service\r\n\r\nDefining a service involves listing the methods that are available on the service. The `service` definition and the methods both support documentation comments and attributes.\r\n\r\n\t/** Service description */\r\n\t[Version(4.0), BasePath(\"/api/token/v4\")]\r\n\tservice TokenGenerator {\r\n\r\n\t\t/// Get a token\r\n\t\t[Http(\"GET\", Path=\"/token.{format}\")]\r\n\t\tFoo GetToken();\r\n\r\n\t\t/// Post a token\r\n\t\t[Http(\"POST\", Path=\"/token.{format}\")]\r\n\t\tFoo PostToken([Body] Foo token);\r\n\r\n\t\t/// Validate a token\r\n\t\t[Http(\"GET\", Path=\"/token.{format}/{tokenId}\")]\r\n\t\tFoo ValidateToken(\r\n\t\t\t/// token specified\r\n\t\t\t[Path, Required] int64 tokenId,\r\n\t\t\t/// Application\r\n\t\t\t[Query] string application\r\n\t\t)\r\n\t\t\r\n\t}\r\n\r\nFor services and methods, there are specific attributes that are used to generate the output. Methods may be declared with a `void` return type if they don't return data.\r\n\r\nUsing Babel\r\n===========\r\n\r\nThe Babel Binary\r\n----------------\r\n\r\n### Installation\r\n\r\nThe only required files are the babel binary and the template folder. Babel has minimal dependencies - just a few shared libraries that should already be on the operating system.\r\n\r\nThe location of the templates folder is based on the location of the babel binary. `/usr/bin` and `/bin` locations are replaced with `/etc` - so effectively, the templates folder is located in the `etc` folder that corresponds to the `bin` folder. If the binary is not in a `bin` folder, then the templates folder is expected to be in the same folder as the binary. Some examples are shown below.\r\n\r\n<table><thead><tr><th>babel binary location</th><th>Default template folder location</th></tr></thead><tbody>\r\n<tr><td>/bin/<strong>babel</strong></td><td>/etc/<strong>babeltemplates</strong></td></tr>\r\n<tr><td>/usr/bin/<strong>babel</strong></td><td>/etc/<strong>babeltemplates</strong></td></tr>\r\n<tr><td>/usr/local/bin/<strong>babel</strong></td><td>/usr/local/etc/<strong>babeltemplates</strong></td></tr>\r\n<tr><td>/usr/local/bin/company/<strong>babel</strong></td><td>/usr/local/etc/company/<strong>babeltemplates</strong></td></tr>\r\n<tr><td>/usr/local/company/bin/<strong>babel</strong></td><td>/usr/local/company/etc/<strong>babeltemplates</strong></td></tr>\r\n<tr><td>c:\\babel\\bin\\<strong>babel.exe</strong></td><td>c:\\babel\\etc\\<strong>babeltemplates</strong></td></tr>\r\n<tr><td>c:\\files\\<strong>babel.exe</strong></td><td>c:\\files\\<strong>babeltemplates</strong></td></tr>\r\n<tr><td>/home/michaell/<strong>babel</strong></td><td>/home/michaell/<strong>babeltemplates</strong></td></tr>\r\n</tbody></table>\r\n\r\n### Command-Line Parameters\r\n\r\n<table><thead><tr><th>Option</th><th>Default</th><th>Description</th></tr></thead><tbody>\r\n<tr><td>-templates</td><td><em>babeltemplates (as shown above)</em></td><td>Use to override the location of the templates folder</td></tr>\r\n<tr><td>-help</td><td>false</td><td>Show command help</td></tr>\r\n<tr><td>-json</td><td>false</td><td>Print the JSON representation of the IDL parse tree</td></tr>\r\n<tr><td>-lang</td><td>csharp</td><td>Generate code in the given language</td></tr>\r\n<tr><td>-output</td><td>gen-lang</td><td>Output folder for generated files</td></tr>\r\n<tr><td>-inc</td><td>false</td><td>Generate included files too</td></tr>\r\n<tr><td>-ns</td><td></td><td>Optionally matches files only if namespace starts with this</td></tr>\r\n<tr><td>-scopes</td><td></td><td>Comma-separated list of scopes to enable</td></tr>\r\n<tr><td>-options</td><td></td><td>Comma-separated list of key=value pairs for generator</td></tr>\r\n<tr><td>-version</td><td></td><td>Display the version number</td></tr>\r\n</tbody></table>\r\n\r\nDevelopment\r\n===========\r\n\r\n## Design\r\n\r\nBabel contains a parse tree [idl.go](https://github.com/babelrpc/babel/blob/master/idl/idl.go), and a [yacc](http://golang.org/cmd/yacc/)\r\nfile [parseidl.y](https://github.com/babelrpc/babel/blob/master/parser/parseidl.y) that implements the parser. The lexical scanner is Go's own\r\n[text scanner](http://golang.org/pkg/text/scanner/) which tokenizes input for C-style\r\nlanguages.\r\n\r\nOutput is generated using Go's [template package](http://golang.org/pkg/text/template/).\r\n\r\n## Coding\r\n\r\nThis project was written in [Go](http://golang.org/). Babel's code documentation is available via [godoc](https://godoc.org/github.com/babelrpc/babel).\r\n","google":"UA-731458-8","note":"Don't delete this file! It's used internally to help with page regeneration."}